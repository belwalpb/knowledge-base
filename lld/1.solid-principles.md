## Solid Principles

#### 1. S: Single Responsibility Principle

- A class should have one, and only one, reason to change.
- It implies that a class should be changed due to the changes in only one functionality.
- If same class can be modified due to various functionalities inside it, then the class is voilating single responsibility principle.

##### How to identify:

- We can ask a simple question before making any changes: What is the responsibility of my class/component/microservice?
- If our answer includes the word “and”, we’re most likely breaking the single responsibility principle. 

##### What we should avoid:

There is no need to have multiple classes that all hold just one function. We always try to find the right balance when defining responsibilities and classes.

#### 2. Open/Closed Principle:

- Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
- The interfaces are closed for modifications, and you can provide new implementations to extend the functionality of your software.

##### When and How to Implement?

Assume we have a class, which is stores the binary data into database.

This class is like:

```java
class BinaryDataDbSaver {
    public void save(Blob binaryData) {
        // ... DB Persistance Logic Here.
    }
}
```

Now a new requirement has been came to save this binary data into an object storage. One possible solution can be like this:

```java
class BinaryDataDbSaver {
    public void saveToDB(Blob binaryData) {
        // ... DB Persistance Logic Here.
    }
    public void saveToBlob(Blob binaryData) {
        // ... DB Persistance Logic Here.
    }
}
```

In above solution, to add a new functionality, we modified an existing class, which was already serving the traffic.

To Handle such scenarios, we can extract the interface from it.

**Example:**

```java
public interface BinaryDataSaver {
    void save(Blob binaryData);
}

class BinaryDataDbSaver implements BinaryDataSaver {
    public void save(Blob binaryData) {
        // ... DB Persistance Logic Here.
    }
}

class BinaryDataBlobSaver implements BinaryDataSaver {
    public void save(Blob binaryData) {
        // ... Blob Persistance Logic Here.
    }
}
```

By adapting this solution, we will not change any implementation of our existing class, which will save data into database.

**Important Pointers:**

- The initial idea of Open/Closed principal was related to the inheritance.
- But inheritance introduces tight coupling if the subclasses depend on implementation details of their parent class.
- Thats why the Open/Closed Principal was re-defined to the Polymorphic Open/Closed Principle. 
- It uses interfaces instead of superclasses to allow different implementations which you can easily substitute without changing the code that uses them.
- The interfaces are closed for modifications, and you can provide new implementations to extend the functionality of your software.


#### 3. Liskov Substitution Principle:

- The principle defines that objects of a superclass shall be replaceable with objects of its subclasses without breaking the application.
- In easy words, subclass should extend the capability of parent class, but not narrow it down.
- An overridden method of a subclass needs to accept the same input parameter values as the method of the superclass.
- By using LSP, we achieves Subtype flexibility, Code reusability.


#### 4. Interface Segregation Principle:

- Clients should not be forced to depend upon interfaces that they do not use.
- In easy words, Interfaces should be such that client should not be forced to implement unnecessary functions that they dont need.
- We should segment one bigger interface in such a way that there should not be any possibility that a client is enforced to implement unnecessary implementation.
- Violating Interface Segregation Principle can also violate Liskov Substitution Principal in case of other methods are not implement properly.


#### 5. Dependency Inversion Principal:

- Classes should depend on interfaces rather than concrete classes.

**Example:**

```java
class MacBook {
    private WiredKeyboard keyboard;
    private WiredMouse mouse;

    public MacBook(WiredKeyboard keyboard, WiredMouse mouse) {
        this.keyboard = keyboard;
        this.mouse = mouse;
    }
}
```

In above example, in future if we would have to replace `WiredKeyboard` to `WirelessKeyboard`, then we need to change the existing class, which can violate Open/Closed Principal and lead to buggy code.

Instead, our MacBook class should rely on interfaces, rather then implementor classes.

**Solution:**

```java
interface Keyboard {
    //... Methods
}

interface Mouse {
    //.. Methods
}

class WiredKeyboard implements Keyboard {
    //... Implementations
}
class WirelessKeyboard implements Keyboard {
    //... Implementations
}

class WiredMouse implements Mouse {
    //... Implementations
}
class WirelessMouse implements Mouse {
    //... Implementations
}

class MacBook {
    private Keyboard keyboard;
    private Mouse mouse;

    public MacBook(Keyboard keyboard, Mouse mouse) {
        this.keyboard = keyboard;
        this.mouse = mouse;
    }
}
```

Now in future, if we need to change the components, we can do it very easily, without disturing the already implemented class.